:stem: asciimath

= Derivation trees 

This section describes some optimized forms of derivation tree storage.

== 1. SPPF
A #shared packed parse forest# (SPPF) is a representation of all of the derivation trees of a given
string a1 . . . an. It's designed to reduce the space required to represent multiple derivation tree

* In the worst case an SPPF can be of unbounded polynomial size
* In binarized form -- worst case cubic size

Contains two types of nodes:

* *symbol* nodes (x, j, i) corresponds to the parsing of substring [i, j] by symbol x. Where 
** x is a terminal or nonterminal: stem:[x \in \{T, N,\epsilon}]. For stem:[x \in N], `x` has one or more packed node children.
** (i, j) -- extent,  0 ≤ j ≤ i ≤ m. 

 Extent ensure that symbol node uniquely identified with it's label (x, j, i)

* *packed* nodes (i), correspond number of rule. We create new packed node for each derivation variant.

  If the grammar is ambiguous a node can have several families of children, corresponding to different parses of the string. Each family is grouped together under a packed node.


Ambiguous result of the parsing:

*set of AST*

image::trees/2024-01-11-17-50-08.png[]

*SPPF* 

image::trees/2024-01-11-17-50-30.png[]

In an SPPF, nodes which have the same tree below them are shared and nodes which correspond to different derivations of the same substring from the same nonterminal are combined by creating a packed node for each family of children. 


image::trees/2024-01-11-17-50-41.png[]


== 2. Binarized SPPF

A binarized SPPF is obtained from a set of indexed BDTs by merging (sharing) nodes with the same label and putting separate families of children under packed nodes <<sjb19>>. 

In order to ensure that the parser has worst-case cubic
runtime, the SPPFs are binarised by introducing #intermediate nodes#. 

* *intermediate* node (L, j, i), where 
** L -- grammar slot the form stem:[A := α · β].
** (i, j) -- extends

 For ambiguous grammars, intermediate node can have several families (?) of children, also grouped together under packed nodes.

 Have packed or symbol nodes as children.

* *packed* nodes (L, k), where 
** L is a grammar slot stem:[X := (\alpha x \cdot \beta, k)]. 
** k is a pivot --  0 ≤ k ≤ m, is an input position
** Have one or two children 
*** Right it's a symbol node stem:[(x, k, i)] which is equal to the left extent of the packed nodes right child.
*** [optional] Left it's a symbol node labelled stem:[X := (\alpha \cdot x \beta, k)] or stem:[(y, j, k)] if stem:[y = \alpha, |\alpha| = 1]. 

 So, we move position in grammar to left. We can say that by intermediate bode we can represent a rule X := abcd as sequence of `binarized` rules X := Cd, C := Bc, B := ab.

* Symbol nodes now has as a children packed nodes -- one for each derivation variant.


*Example* <<sjb19>>

Grammar 

```
S := b a c | b a a | b A c 
A := a
```

SPPF for string `bac`

rectangular -- intermediate

image::trees/sppf_sjb_1.png[]

The two packed node children of the root node (S, 0, 3) correspond to two derivations, one using
each of the rules which label the packed nodes. The SPPF embeds the two (binarized) derivation
trees below.

image::trees/sppf_sjb_2.png[]

*Example 1* <<izm>>

image::trees/sppf_izm_1.png[]

*Example 2* <<izm>>

image::trees/sppf_izm.png[]

*Example 3*

Grammar: 

stem:[
S \to ABCD, \ A \to a, \ B \to b, \ C \to c, \ D \to d 
]

*Simple SPPF*

image::trees/2024-01-11-18-25-29.png[]

*Binarized SPPF*

image::trees/2024-01-11-18-26-18.png[]

=== SPPF Construction

== 3. BSR set: binary subtree representations set <<sjb19>>

If a packed node, w, has children (β, i, k) and (x, k, j) then w has label (βx, k) or (X ::= βx, k), so we can compute the
children, and the parent, of w if the label of w is modified to be (βx, i, k, j) or (X ::= βx, i, k, j). 

So we can merge 3 node into one BSR element.

The #BSR element# in stem:[\Gamma] is a 4-tuple stem:[(\Omega, i, k, j)], where 0 ≤ i ≤ k ≤ j and stem:[\Omega] in one of the form:

* stem:[X, X := α] is a production in stem:[\Gamma], 
* stem:[\beta, |\beta| > 1] and for some X and δ, stem:[X := βδ] is a production in stem:[\Gamma].

=== Example 
*Grammar* 

image::trees/2024-01-12-14-15-23.png[]

*Input*: "aab"

*Binarised SPPF*

image::trees/2024-01-12-14-24-15.png[]

*BSR set*

stem:[\{(S := a AB, 0, 2, 3), (S := a Ab, 0, 2, 3), (a A, 0, 1, 2), (B := b, 2, 2, 3), (A := a, 1, 1, 2)}]

We can restore binarized SPPF from BSR set.

* No need for graph construction machinery -> Parsers that generate BSR sets are simpler to construct and require less runtime space
* No edges are computed or stored. 

 So you can't apply to this structure error-recovery algorithms with labels on sppf (we use this labels in error-recovery?).

[bibliography]
== References

* [[[sjb19]]] Elizabeth Scott, Adrian Johnstone, L. Thomas van Binsbergen,
Derivation representation using binary subtree sets,
Science of Computer Programming, Volume 175,
2019, Pages 63-84
* [[[izm]]] thesis Izmailova