:stem: asciimath

= Yacc  <<asu86>>
* Algorithm: LARL 
* Source language: C

Yacc translator routine:

image::yacc/yacc_routine.png[]


A Yacc source program has three parts, divided by `%%`:

* declarations
** c-headers including
** grammar tokens, they can be used in parts below and in Lex analyzer (if it used) 
* translation rules
* supporting C routines

== Translation rules 
Each rule consists of a grammar production and the associated semantic action 

For set of productions 

`<head>` -> `<body_1>` | .. | `<body_n>`

would be written

```
<head>  : <body_1> {<semantic_action_1>}
        ... 
        | <body_n> {<semantic_action_n>}
        ;
```
== Semantic actions
Semantic action is a sequence of C statements.

In the action the symbol $$ refers to the attribute value associated with the nonterminal of
the head, while $i refers to the value associated with the i-th grammar symbol
(terminal or nonterminal) of the body. 

The semantic action is performed whenever we reduce by the associated production

* associativity: `%right UMINUS`, `%nonassoc '<'`
* precedence `%prec UMINUS`. The operators with the lowest priority are on top, the operators with the highest priority are on the bottom.

*Example: Yacc specication of a simple desk calculator*

```
%{
    #include <ctype.h>
    #include <stdio.h>
    #define YYSTYPE double /* double type for Yacc stack */
%}
%token NUMBER
%left '+' '-'
%left '*' '/'
%right UMINUS

%%

lines   : lines expr '\n' { printf("%g\n", $2); }
        | lines '\n'
        | /* empty */
        | error '\n'    {  
                            yyerror("reenter previous line:");
                            yyerrok;
                        }
        ;
        
expr    : expr '+' expr { $$ = $1 + $3; }
        | expr '-' expr { $$ = $1 - $3; }
        | expr '*' expr { $$ = $1 * $3; }
        | expr '/' expr { $$ = $1 / $3; }
        | '(' expr ')' { $$ = $2; }
        | '-' expr %prec UMINUS { $$ = - $2; }
        | NUMBER
        ;

%%

    yylex() {
    int c;
    while ((c = getchar()) == ' ');
    if ((c == '.') || (isdigit(c))) {
        ungetc(c, stdin);
        scanf("%lf", &yylval);
        return NUMBER;
    }
    return c;
}
```

* associativity: `%right UMINUS`
* precedence `%prec UMINUS`, `%nonassoc '<'`

== Error recovery
In Yacc error recovery uses a form of error productions. First, the user decides what "major" nonterminals will have error recovery associated with them. Fnd label with keyword `error`: `A` -> *error* x.

On encountering an error, Yacc pops symbols from its stack until it finds the topmost state on its stack whose underlying set of items includes an item of the
form `A` -> .*error* `x` The parser then "shifts" actitions token error onto the
stack, as though it saw the token error on its input.



[bibliography]
== References

* [[[asu86]]] Alfred V. Aho, Ravi Sethi, Jeffrey D. Ullman, Compilers: Principles, Techniques, and Tools, Addison-Wesley, 1986